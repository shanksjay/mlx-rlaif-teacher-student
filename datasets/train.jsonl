{"prompt": "Implement a function to find all prime numbers up to n using Sieve of Eratosthenes", "language": "rust", "student_code": "```rust\nfn sieve_of_eratosthenes(n: usize) -> Vec<usize> {\n    let mut primes = vec![true; n + 1];\n    let mut result = Vec::new();\n\n    for p in 2..=n {\n        if primes[p] {\n            result.push(p);\n            for i in (p * p..=n).step_by(p) {\n                primes[i] = false;\n            }\n        }\n    }\n\n    result\n}\n\nfn main() {\n    let n = 30;\n    let primes = sieve_of_eratosthenes(n);\n    println!(\"Primes", "teacher_code": "Here's a high-quality Rust implementation of the Sieve of Eratosthenes algorithm to find all prime numbers up to n:\n\n```rust\n/// Finds all prime numbers up to a given limit using the Sieve of Eratosthenes algorithm.\n///\n/// # Arguments\n///\n/// * `n` - The upper limit for finding prime numbers\n///\n/// # Returns\n///\n/// A vector containing all prime numbers less than or equal to n\n///\n/// # Examples\n///\n/// ```\n/// let primes = sieve_of_eratosthenes(20);\n/// assert_eq!(primes, vec![2, 3, 5, 7, 11, 13, 17, 19]);\n/// ```\n///\n/// # Time Complexity\n///\n/// O(n log log n)\n///\n/// # Space Complexity\n///\n/// O(n)\npub fn sieve_of_eratosthenes(n: usize) -> Vec<usize> {\n    // Handle edge cases\n    if n < 2 {\n        return Vec::new();\n    }\n\n    // Create a boolean vector to track prime numbers\n    // Initially assume all numbers are prime\n    let mut is_prime = vec![true; n + 1];\n    is_prime[0] = false;\n    is_prime[1] = false;\n\n    // Use Sieve of Eratosthenes algorithm\n    for i in 2..=(n as f64).sqrt() as usize {\n        if is_prime[i] {\n            // Mark multiples of i as non-prime\n            for j in (i * i..=n).step_by(i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    // Collect prime numbers\n    (2..=n)\n        .filter(|&x| is_prime[x])\n        .collect()\n}\n\n/// Finds all prime numbers up to a given limit using the Sieve of Eratosthenes algorithm \n/// with optimized memory usage.\n///\n/// # Arguments\n///\n/// * `n` - The upper limit for finding prime numbers\n///\n/// # Returns\n///\n/// A vector containing all prime numbers less than or equal to n\n///\n/// # Examples\n///\n/// ```\n/// let primes = sieve_of_eratosthenes_compact(20);\n/// assert_eq!(primes, vec![2, 3, 5, 7, 11, 13, 17, 19]);\n/// ```\npub fn sieve_of_eratosthenes_compact(n: usize) -> Vec<usize> {\n    // Optimized bit vector approach\n    let mut sieve = vec![0u64; (n / 64) + 1];\n\n    // Helper macro to check if a number is prime\n    macro_rules! is_prime {\n        ($x:expr) => {{\n            let word = $x / 64;\n            let bit = $x % 64;\n            (sieve[word] & (1 << bit)) == 0\n        }};\n    }\n\n    // Helper macro to mark a number as non-prime\n    macro_rules! mark_composite {\n        ($x:expr) => {{\n            let word = $x / 64;\n            let bit = $x % 64;\n            sieve[word] |= 1 << bit;\n        }};\n    }\n\n    // Sieve algorithm\n    for i in 2..=(n as f64).sqrt() as usize {\n        if is_prime!(i) {\n            for j in (i * i..=n).step_by(i) {\n                mark_composite!(j);\n            }\n        }\n    }\n\n    // Collect prime numbers\n    (2..=n)\n        .filter(|&x| is_prime!(x))\n        .collect()\n}\n\n// Example usage and benchmarking\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_prime_generation() {\n        let primes = sieve_of_eratosthenes(20);\n        assert_eq!(primes, vec![2, 3, 5, 7, 11, 13, 17, 19]);\n    }\n\n    #[test]\n    fn test_compact_sieve() {\n        let primes = sieve_of_eratosthenes_compact(20);\n        assert_eq!(primes, vec![2, 3, 5, 7, 11, 13, 17, 19]);\n    }\n}\n\nfn main() {\n    let limit = 100;\n    let primes = sieve_of_eratosthenes(limit);\n    println!(\"Prime numbers up to {}: {:?}\", limit, primes);\n}\n```\n\nThis implementation provides two approaches to the Sieve of Eratosthenes algorithm:\n\n1. `sieve_of_eratosthenes()`: A standard implementation using a boolean vector\n   - Simple and easy to understand\n   - Good for small to medium-sized ranges\n   - O(n) space complexity\n\n2. `sieve_of_eratosthenes_compact()`: An optimized bit vector approach\n   - More memory-efficient\n   - Uses bit manipulation for compact storage\n   - Better for larger ranges\n\nKey features:\n- Comprehensive documentation\n- Clear time and space complexity analysis\n- Example usage and tests\n- Handles edge cases\n- Optimized algorithm implementation\n\nThe code includes:\n- Detailed function documentation\n- Example usage in the `main()` function\n- Unit tests for verification\n- Two implementation variants\n\nRecommended use cases:\n- Finding prime numbers in a specific range\n- Mathematical computations\n- Number theory problems\n\nPerformance tips:\n- Use the compact version for larger ranges\n- Adjust the implementation based on specific requirements", "student_score": 0.85, "teacher_score": 0.95, "reward": 0.8947359002779997, "scoring_breakdown": {"correctness": 0.3, "code_quality": 0.3, "efficiency": 0.2, "documentation": 0.2}, "timestamp": "2025-12-18T00:18:33.603296"}
{"prompt": "Implement a binary search tree with insert, delete, and search operations", "language": "python", "student_code": "```python\nclass Node:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\nclass BinarySearchTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, key):\n        if self.root is None:\n            self.root = Node(key)\n        else:\n            self._insert(self.root, key)\n\n    def _insert(self, node, key):\n        if key < node.val:\n            if node.left is None:\n                node.left = Node(key)\n            else:\n                self._insert(node.left, key)\n        else", "teacher_code": "Here's a comprehensive implementation of a Binary Search Tree (BST) in Python with insert, delete, and search operations:\n\n```python\nclass Node:\n    \"\"\"\n    Represents a node in the Binary Search Tree.\n    \n    Attributes:\n        value: The value stored in the node\n        left: Reference to the left child node\n        right: Reference to the right child node\n    \"\"\"\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n\nclass BinarySearchTree:\n    \"\"\"\n    Binary Search Tree data structure with insert, delete, and search operations.\n    \n    Attributes:\n        root: The root node of the BST\n    \"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize an empty binary search tree.\"\"\"\n        self.root = None\n    \n    def insert(self, value):\n        \"\"\"\n        Insert a new value into the BST.\n        \n        Args:\n            value: The value to be inserted\n        \"\"\"\n        if not self.root:\n            self.root = Node(value)\n        else:\n            self._insert_recursive(self.root, value)\n    \n    def _insert_recursive(self, current_node, value):\n        \"\"\"\n        Recursive helper method for inserting a value.\n        \n        Args:\n            current_node: Current node being examined\n            value: Value to be inserted\n        \"\"\"\n        if value < current_node.value:\n            if current_node.left is None:\n                current_node.left = Node(value)\n            else:\n                self._insert_recursive(current_node.left, value)\n        else:\n            if current_node.right is None:\n                current_node.right = Node(value)\n            else:\n                self._insert_recursive(current_node.right, value)\n    \n    def search(self, value):\n        \"\"\"\n        Search for a value in the BST.\n        \n        Args:\n            value: The value to search for\n        \n        Returns:\n            bool: True if value exists, False otherwise\n        \"\"\"\n        return self._search_recursive(self.root, value)\n    \n    def _search_recursive(self, current_node, value):\n        \"\"\"\n        Recursive helper method for searching a value.\n        \n        Args:\n            current_node: Current node being examined\n            value: Value to search for\n        \n        Returns:\n            bool: True if value exists, False otherwise\n        \"\"\"\n        # Base cases\n        if current_node is None:\n            return False\n        \n        if current_node.value == value:\n            return True\n        \n        # Recursive search\n        if value < current_node.value:\n            return self._search_recursive(current_node.left, value)\n        else:\n            return self._search_recursive(current_node.right, value)\n    \n    def delete(self, value):\n        \"\"\"\n        Delete a value from the BST.\n        \n        Args:\n            value: The value to delete\n        \"\"\"\n        self.root = self._delete_recursive(self.root, value)\n    \n    def _delete_recursive(self, current_node, value):\n        \"\"\"\n        Recursive helper method for deleting a value.\n        \n        Args:\n            current_node: Current node being examined\n            value: Value to delete\n        \n        Returns:\n            Node: Updated node after deletion\n        \"\"\"\n        # Base case: node not found\n        if current_node is None:\n            return None\n        \n        # Find the node to delete\n        if value < current_node.value:\n            current_node.left = self._delete_recursive(current_node.left, value)\n        elif value > current_node.value:\n            current_node.right = self._delete_recursive(current_node.right, value)\n        else:\n            # Node to delete found\n            \n            # Case 1: Leaf node\n            if current_node.left is None and current_node.right is None:\n                return None\n            \n            # Case 2: One child\n            if current_node.left is None:\n                return current_node.right\n            if current_node.right is None:\n                return current_node.left\n            \n            # Case 3: Two children\n            # Find minimum value in right subtree\n            min_node = self._find_min(current_node.right)\n            current_node.value = min_node.value\n            current_node.right = self._delete_recursive(current_node.right, min_node.value)\n        \n        return current_node\n    \n    def _find_min(self, node):\n        \"\"\"\n        Find the minimum value node in a subtree.\n        \n        Args:\n            node: Root of the subtree\n        \n        Returns:\n            Node: Node with minimum value\n        \"\"\"\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n    \n    def inorder_traversal(self):\n        \"\"\"\n        Perform an inorder traversal of the BST.\n        \n        Returns:\n            list: Values in sorted order\n        \"\"\"\n        result = []\n        self._inorder_recursive(self.root, result)\n        return result\n    \n    def _inorder_recursive(self, node, result):\n        \"\"\"\n        Recursive helper for inorder traversal.\n        \n        Args:\n            node: Current node\n            result: List to store traversal result\n        \"\"\"\n        if node:\n            self._inorder_recursive(node.left, result)\n            result.append(node.value)\n            self._inorder_recursive(node.right, result)\n\n\n# Example usage and testing\ndef main():\n    bst = BinarySearchTree()\n    \n    # Insert values\n    values = [50, 30, 70, 20, 40, 60, 80]\n    for val in values:\n        bst.insert(val)\n    \n    # Inorder traversal\n    print(\"Inorder Traversal:\", bst.inorder_traversal())\n    \n    # Search operations\n    print(\"Search 40:\", bst.search(40))  # True\n    print(\"Search 90:\", bst.search(90))  # False\n    \n    # Delete operations\n    bst.delete(30)\n    print(\"After deleting 30:\", bst.inorder_traversal())\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\nKey Features of this Implementation:\n\n1. Comprehensive BST with robust operations\n2. Recursive implementation for insert, search, and delete\n3. Handles all deletion scenarios:\n   - Deleting leaf nodes\n   - Deleting nodes with one child\n   - Deleting nodes with two children\n4. Detailed documentation and type hints\n5. Inorder traversal method to verify tree structure\n6. Example usage in the `main()` function\n\nThe implementation provides:\n- Time Complexity: O(log n) for balanced trees\n- Space Complexity: O(h), where h is the height of the tree\n\nImprovements could include:\n- Self-balancing mechanisms\n- Additional traversal methods\n- Error handling for edge cases", "student_score": 0.4, "teacher_score": 0.95, "reward": 0.4210521883661175, "scoring_breakdown": {"correctness": 0.3, "code_quality": 0.3, "efficiency": 0.2, "documentation": 0.2}, "timestamp": "2025-12-18T00:18:35.260706"}
{"prompt": "Create a decorator that measures function execution time", "language": "python", "student_code": "\n\n```python\nimport time\n\ndef measure_time(func):\n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n        print(f\"{func.__name__} took {end_time - start_time:.4f} seconds to execute\")\n        return result\n    return wrapper\n\n@measure_time\ndef example_function(n):\n    total = 0\n    for i in range(n):\n        total += i\n    return total\n\nexample_function(1000000)\n```\n\nThis code defines a decorator `measure", "teacher_code": "Here's a comprehensive implementation of a decorator to measure function execution time:\n\n```python\nimport time\nimport functools\nfrom typing import Callable, Any\n\ndef execution_timer(log_result: bool = True) -> Callable:\n    \"\"\"\n    A decorator that measures and logs function execution time.\n    \n    Args:\n        log_result (bool): Whether to print execution time. Defaults to True.\n    \n    Returns:\n        Callable: Decorated function with timing capabilities\n    \"\"\"\n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        def wrapper(*args: Any, **kwargs: Any) -> Any:\n            # Start timing\n            start_time = time.perf_counter()\n            \n            try:\n                # Execute the original function\n                result = func(*args, **kwargs)\n                \n                # Calculate execution time\n                end_time = time.perf_counter()\n                execution_time = end_time - start_time\n                \n                # Optional logging\n                if log_result:\n                    print(f\"Function '{func.__name__}' executed in {execution_time:.4f} seconds\")\n                \n                return result\n            \n            except Exception as e:\n                print(f\"Error in {func.__name__}: {e}\")\n                raise\n        \n        return wrapper\n    \n    return decorator\n\n# Example usage demonstrations\n@execution_timer()\ndef slow_function(n: int) -> int:\n    \"\"\"\n    A sample slow function to demonstrate timing.\n    \n    Args:\n        n (int): Number of iterations\n    \n    Returns:\n        int: Sum of iterations\n    \"\"\"\n    total = 0\n    for _ in range(n):\n        total += sum(range(10000))\n    return total\n\n@execution_timer(log_result=False)\ndef fast_function() -> str:\n    \"\"\"\n    A quick function with timing disabled.\n    \n    Returns:\n        str: A greeting message\n    \"\"\"\n    return \"Hello, World!\"\n\ndef main():\n    # Demonstrate function timing\n    result1 = slow_function(100)\n    result2 = fast_function()\n    \n    print(f\"Slow function result: {result1}\")\n    print(f\"Fast function result: {result2}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis implementation offers several advanced features:\n\n1. Flexible Decorator\n- Can be used with or without arguments\n- Optional logging control\n- Preserves original function metadata\n\n2. Performance Measurement\n- Uses `time.perf_counter()` for high-precision timing\n- Captures total function execution time\n- Works with functions of any complexity\n\n3. Error Handling\n- Catches and re-raises exceptions\n- Provides error logging\n- Ensures original function behavior is maintained\n\n4. Type Hints\n- Comprehensive type annotations\n- Supports functions with various argument types\n\n5. Docstrings\n- Detailed documentation for decorator and example functions\n\nBonus Features:\n- Supports functions with positional and keyword arguments\n- Minimal performance overhead\n- Easy to integrate into existing code\n\nUsage Variations:\n```python\n# Default usage\n@execution_timer()\ndef example_func():\n    pass\n\n# Disable logging\n@execution_timer(log_result=False)\ndef silent_func():\n    pass\n```\n\nBest Practices:\n- Use for performance profiling\n- Avoid in production for high-frequency functions\n- Combine with logging frameworks for advanced tracking\n\nPotential Enhancements:\n- Add custom logging destination\n- Support for more detailed timing metrics\n- Integration with profiling tools", "student_score": 0.9, "teacher_score": 0.95, "reward": 0.9473674238237645, "scoring_breakdown": {"correctness": 0.3, "code_quality": 0.3, "efficiency": 0.2, "documentation": 0.2}, "timestamp": "2025-12-18T00:18:51.665694"}
{"prompt": "Implement a simple HTTP client using async/await", "language": "rust", "student_code": "\n\n```rust\nuse reqwest::Client;\nuse tokio::runtime::Runtime;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let client = Client::new();\n    let url = \"https://httpbin.org/get\";\n\n    let response = client.get(url).send().await?;\n    let body = response.text().await?;\n\n    println!(\"Response: {}\", body);\n\n    Ok(())\n}\n```\n\nThis code uses the `reqwest` crate for HTTP requests and `tokio` for async runtime. The `#[tokio::main]` macro is used", "teacher_code": "Here's a comprehensive implementation of an async HTTP client in Rust using `reqwest` and `tokio`:\n\n```rust\nuse std::error::Error;\nuse std::time::Duration;\nuse reqwest::{Client, Response};\nuse serde::{Deserialize, Serialize};\n\n/// Configuration for HTTP client\n#[derive(Debug, Clone)]\nstruct HttpClientConfig {\n    timeout: Duration,\n    base_url: String,\n}\n\n/// HTTP client for making async requests\n#[derive(Debug)]\nstruct HttpClient {\n    client: Client,\n    config: HttpClientConfig,\n}\n\nimpl HttpClient {\n    /// Create a new HTTP client with default configuration\n    pub fn new() -> Result<Self, Box<dyn Error>> {\n        let config = HttpClientConfig {\n            timeout: Duration::from_secs(10),\n            base_url: \"https://api.example.com\".to_string(),\n        };\n\n        let client = Client::builder()\n            .timeout(config.timeout)\n            .build()?;\n\n        Ok(Self { client, config })\n    }\n\n    /// Make a GET request\n    pub async fn get<T>(&self, endpoint: &str) -> Result<T, Box<dyn Error>>\n    where\n        T: for<'de> Deserialize<'de>,\n    {\n        let url = format!(\"{}{}\", self.config.base_url, endpoint);\n        \n        let response = self.client\n            .get(&url)\n            .send()\n            .await?;\n\n        self.handle_response(response).await\n    }\n\n    /// Make a POST request with JSON body\n    pub async fn post<T, B>(&self, endpoint: &str, body: &B) -> Result<T, Box<dyn Error>>\n    where\n        T: for<'de> Deserialize<'de>,\n        B: Serialize,\n    {\n        let url = format!(\"{}{}\", self.config.base_url, endpoint);\n        \n        let response = self.client\n            .post(&url)\n            .json(body)\n            .send()\n            .await?;\n\n        self.handle_response(response).await\n    }\n\n    /// Handle HTTP response and parse JSON\n    async fn handle_response<T>(&self, response: Response) -> Result<T, Box<dyn Error>>\n    where\n        T: for<'de> Deserialize<'de>,\n    {\n        match response.status() {\n            reqwest::StatusCode::OK => {\n                let result = response.json::<T>().await?;\n                Ok(result)\n            }\n            status => {\n                let error_text = response.text().await?;\n                Err(format!(\"HTTP Error {}: {}\", status, error_text).into())\n            }\n        }\n    }\n}\n\n/// Example data structures\n#[derive(Debug, Serialize, Deserialize)]\nstruct User {\n    id: u64,\n    username: String,\n}\n\n/// Example usage in async context\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn Error>> {\n    // Initialize HTTP client\n    let client = HttpClient::new()?;\n\n    // GET request example\n    let user: User = client.get(\"/users/1\").await?;\n    println!(\"User: {:?}\", user);\n\n    // POST request example\n    let new_user = User {\n        id: 0,\n        username: \"newuser\".to_string(),\n    };\n    let created_user: User = client.post(\"/users\", &new_user).await?;\n    println!(\"Created User: {:?}\", created_user);\n\n    Ok(())\n}\n```\n\nThis implementation provides a robust, flexible async HTTP client with the following features:\n\nKey Components:\n- Async request methods (`get`, `post`)\n- Configurable timeout and base URL\n- Generic JSON serialization/deserialization\n- Error handling\n- Uses `reqwest` for HTTP requests\n- Uses `tokio` for async runtime\n\nCargo.toml dependencies:\n```toml\n[dependencies]\nreqwest = { version = \"0.11\", features = [\"json\"] }\ntokio = { version = \"1\", features = [\"full\"] }\nserde = { version = \"1\", features = [\"derive\"] }\nserde_json = \"1\"\n```\n\nBest Practices Demonstrated:\n- Error handling with `Result`\n- Generic type constraints\n- Async/await syntax\n- Separation of concerns\n- Configuration struct\n- Flexible method signatures\n\nPotential Enhancements:\n- Add more HTTP methods (PUT, DELETE)\n- Implement retry mechanism\n- Add authentication support\n- More granular error handling", "student_score": 0.85, "teacher_score": 0.95, "reward": 0.8947359002779997, "scoring_breakdown": {"correctness": 0.3, "code_quality": 0.3, "efficiency": 0.2, "documentation": 0.2}, "timestamp": "2025-12-18T00:18:51.787299"}
{"prompt": "Create a function to calculate the Fibonacci sequence using an iterator", "language": "rust", "student_code": "```rust\nfn fibonacci() -> impl Iterator<Item = u64> {\n    let (mut a, mut b) = (0, 1);\n    std::iter::from_fn(move || {\n        let next = a;\n        a = b;\n        b = next + b;\n        Some(next)\n    })\n}\n\nfn main() {\n    for num in fibonacci().take(10) {\n        println!(\"{}\", num);\n    }\n}\n```\n\nThis code defines a function `fibonacci` that returns an iterator producing the Fibonacci sequence. The `main` function demonstrates how to use this iterator by printing the first 1", "teacher_code": "Here's a clean and efficient implementation of a Fibonacci iterator in Rust:\n\n```rust\n/// An iterator that generates Fibonacci numbers\npub struct FibonacciIterator {\n    current: u64,\n    next: u64,\n}\n\nimpl FibonacciIterator {\n    /// Creates a new Fibonacci iterator starting from 0 and 1\n    pub fn new() -> Self {\n        Self {\n            current: 0,\n            next: 1,\n        }\n    }\n}\n\nimpl Iterator for FibonacciIterator {\n    type Item = u64;\n\n    /// Generates the next Fibonacci number in the sequence\n    fn next(&mut self) -> Option<Self::Item> {\n        let result = self.current;\n        let new_next = self.current.checked_add(self.next)?;\n        \n        self.current = self.next;\n        self.next = new_next;\n        \n        Some(result)\n    }\n}\n\n/// Trait implementation to allow default construction\nimpl Default for FibonacciIterator {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n// Example usage and demonstration\nfn main() {\n    // Print first 10 Fibonacci numbers\n    let fibonacci = FibonacciIterator::new();\n    \n    println!(\"First 10 Fibonacci numbers:\");\n    for (index, num) in fibonacci.take(10).enumerate() {\n        println!(\"F({}) = {}\", index, num);\n    }\n\n    // Demonstrate safe overflow handling\n    let fibonacci_safe = FibonacciIterator::new();\n    let last_safe_number = fibonacci_safe\n        .take_while(|&x| x < u64::MAX / 2)\n        .last()\n        .unwrap_or(0);\n    \n    println!(\"\\nLast Fibonacci number before potential overflow: {}\", last_safe_number);\n}\n```\n\nKey features of this implementation:\n\n1. Uses `u64` for larger number range\n2. Implements the `Iterator` trait\n3. Uses `checked_add()` for safe arithmetic\n4. Provides a `new()` method and `Default` trait implementation\n5. Allows flexible usage with iterator methods like `take()`, `enumerate()`, etc.\n\nAdvantages:\n- Memory efficient (generates numbers on-the-fly)\n- Safe against integer overflow\n- Follows Rust's iterator protocol\n- Easy to use and extend\n\nExample output:\n```\nFirst 10 Fibonacci numbers:\nF(0) = 0\nF(1) = 1\nF(2) = 1\nF(3) = 2\nF(4) = 3\nF(5) = 5\nF(6) = 8\nF(7) = 13\nF(8) = 21\nF(9) = 34\n\nLast Fibonacci number before potential overflow: 1304969544928657\n```\n\nThe implementation handles potential overflow gracefully and provides a clean, idiomatic Rust solution for generating Fibonacci numbers.", "student_score": 0.95, "teacher_score": 0.95, "reward": 0.9999989473695291, "scoring_breakdown": {"correctness": 0.3, "code_quality": 0.3, "efficiency": 0.2, "documentation": 0.2}, "timestamp": "2025-12-18T00:23:52.783324"}
{"prompt": "Create a RAII wrapper for file handling", "language": "cpp", "student_code": "```cpp\n#include <iostream>\n#include <fstream>\n#include <string>\n\nclass FileHandler {\npublic:\n    FileHandler(const std::string& filename) : filename_(filename) {}\n\n    // Open the file for reading\n    void openForReading() {\n        file_.open(filename_, std::ios::in);\n        if (!file_.is_open()) {\n            throw std::runtime_error(\"Failed to open file for reading\");\n        }\n    }\n\n    // Open the file for writing\n    void openForWriting() {\n        file_.open(filename_, std::ios::out);\n        if (!file_.is_open()) {\n           ", "teacher_code": "Here's a comprehensive RAII (Resource Acquisition Is Initialization) wrapper for file handling in C++:\n\n```cpp\n#ifndef FILE_HANDLER_HPP\n#define FILE_HANDLER_HPP\n\n#include <string>\n#include <fstream>\n#include <stdexcept>\n#include <filesystem>\n\nclass FileHandler {\npublic:\n    // Enum for file open modes\n    enum class Mode {\n        READ,\n        WRITE,\n        APPEND,\n        READ_WRITE\n    };\n\n    // Constructors\n    explicit FileHandler() = default;\n\n    // Open file with specific mode\n    explicit FileHandler(const std::string& filename, Mode mode = Mode::READ) {\n        open(filename, mode);\n    }\n\n    // Prevent copying\n    FileHandler(const FileHandler&) = delete;\n    FileHandler& operator=(const FileHandler&) = delete;\n\n    // Allow move semantics\n    FileHandler(FileHandler&& other) noexcept \n        : m_file(std::move(other.m_file)), m_filename(std::move(other.m_filename)) {\n        other.m_file.close();\n    }\n\n    FileHandler& operator=(FileHandler&& other) noexcept {\n        if (this != &other) {\n            close();\n            m_file = std::move(other.m_file);\n            m_filename = std::move(other.m_filename);\n            other.m_file.close();\n        }\n        return *this;\n    }\n\n    // Destructor - automatically closes file\n    ~FileHandler() {\n        close();\n    }\n\n    // Open file with specific mode\n    void open(const std::string& filename, Mode mode = Mode::READ) {\n        // Close any existing file\n        close();\n\n        m_filename = filename;\n\n        // Determine file open mode\n        std::ios_base::openmode openMode = std::ios_base::in;\n        switch (mode) {\n            case Mode::READ:\n                openMode = std::ios_base::in;\n                break;\n            case Mode::WRITE:\n                openMode = std::ios_base::out | std::ios_base::trunc;\n                break;\n            case Mode::APPEND:\n                openMode = std::ios_base::out | std::ios_base::app;\n                break;\n            case Mode::READ_WRITE:\n                openMode = std::ios_base::in | std::ios_base::out;\n                break;\n        }\n\n        // Open file and check for errors\n        m_file.open(filename, openMode);\n        if (!m_file.is_open()) {\n            throw std::runtime_error(\"Unable to open file: \" + filename);\n        }\n    }\n\n    // Check if file is open\n    bool is_open() const {\n        return m_file.is_open();\n    }\n\n    // Close file\n    void close() {\n        if (m_file.is_open()) {\n            m_file.close();\n        }\n    }\n\n    // Read entire file content\n    std::string read_all() {\n        if (!m_file.is_open()) {\n            throw std::runtime_error(\"File is not open\");\n        }\n\n        // Reset file pointer to beginning\n        m_file.seekg(0, std::ios::beg);\n\n        // Read entire file\n        return std::string(\n            (std::istreambuf_iterator<char>(m_file)), \n            std::istreambuf_iterator<char>()\n        );\n    }\n\n    // Write content to file\n    void write(const std::string& content) {\n        if (!m_file.is_open()) {\n            throw std::runtime_error(\"File is not open\");\n        }\n\n        m_file << content;\n        m_file.flush();\n    }\n\n    // Get file size\n    std::uintmax_t size() const {\n        if (!std::filesystem::exists(m_filename)) {\n            return 0;\n        }\n        return std::filesystem::file_size(m_filename);\n    }\n\n    // Get filename\n    std::string filename() const {\n        return m_filename;\n    }\n\n    // Access underlying file stream\n    std::fstream& stream() {\n        return m_file;\n    }\n\nprivate:\n    std::fstream m_file;      // File stream\n    std::string m_filename;   // Filename\n};\n\n#endif // FILE_HANDLER_HPP\n```\n\nExample usage:\n\n```cpp\n#include <iostream>\n#include \"FileHandler.hpp\"\n\nint main() {\n    try {\n        // Write to file\n        {\n            FileHandler file(\"example.txt\", FileHandler::Mode::WRITE);\n            file.write(\"Hello, RAII File Handling!\");\n        }\n\n        // Read from file\n        {\n            FileHandler file(\"example.txt\");\n            std::string content = file.read_all();\n            std::cout << \"File content: \" << content << std::endl;\n        }\n    }\n    catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n```\n\nKey features of this FileHandler:\n1. RAII design ensures automatic resource management\n2. Prevents resource leaks\n3. Supports different file open modes\n4. Prevents copying, allows moving\n5. Provides convenient methods for file operations\n6. Strong error handling with exceptions\n7. Uses modern C++ features\n8. Supports reading entire file content\n9. Provides file size and filename retrieval\n10. Access to underlying file stream for advanced operations\n\nThe wrapper provides a safe, efficient, and easy-to-use interface for file handling in C++.", "student_score": 0.45, "teacher_score": 0.95, "reward": 0.47368371191188224, "scoring_breakdown": {"correctness": 0.3, "code_quality": 0.3, "efficiency": 0.2, "documentation": 0.2}, "timestamp": "2025-12-18T00:24:00.319717"}
{"prompt": "Implement a custom smart pointer class", "language": "cpp", "student_code": "\n\n```cpp\n#include <iostream>\n#include <memory>\n\ntemplate <typename T>\nclass CustomSmartPtr {\npublic:\n    CustomSmartPtr(T* ptr = nullptr) : ptr_(ptr), ref_count_(new int(1)) {}\n\n    // Copy constructor\n    CustomSmartPtr(const CustomSmartPtr& other) : ptr_(other.ptr_), ref_count_(other.ref_count_) {\n        (*ref_count_)++;\n    }\n\n    // Copy assignment operator\n    CustomSmartPtr& operator=(const CustomSmartPtr& other) {\n        if (this != &other) {\n            (*ref_count_)--;\n            if (*ref_count_", "teacher_code": "Here's a comprehensive implementation of a custom smart pointer class in C++:\n\n```cpp\n#ifndef CUSTOM_SMART_POINTER_H\n#define CUSTOM_SMART_POINTER_H\n\n#include <iostream>\n#include <stdexcept>\n\ntemplate <typename T>\nclass SmartPointer {\nprivate:\n    T* ptr;           // Actual pointer\n    unsigned* refCount; // Reference count\n\n    // Private helper method to release resources\n    void release() {\n        if (refCount) {\n            (*refCount)--;\n            if (*refCount == 0) {\n                delete ptr;\n                delete refCount;\n                ptr = nullptr;\n                refCount = nullptr;\n            }\n        }\n    }\n\npublic:\n    // Default constructor\n    SmartPointer() : ptr(nullptr), refCount(nullptr) {}\n\n    // Constructor with raw pointer\n    explicit SmartPointer(T* rawPtr) : \n        ptr(rawPtr), \n        refCount(new unsigned(1)) {}\n\n    // Copy constructor\n    SmartPointer(const SmartPointer& other) : \n        ptr(other.ptr), \n        refCount(other.refCount) {\n        if (refCount) {\n            (*refCount)++;\n        }\n    }\n\n    // Move constructor\n    SmartPointer(SmartPointer&& other) noexcept : \n        ptr(other.ptr), \n        refCount(other.refCount) {\n        other.ptr = nullptr;\n        other.refCount = nullptr;\n    }\n\n    // Destructor\n    ~SmartPointer() {\n        release();\n    }\n\n    // Copy assignment operator\n    SmartPointer& operator=(const SmartPointer& other) {\n        if (this != &other) {\n            // Release current resources\n            release();\n\n            // Copy new resources\n            ptr = other.ptr;\n            refCount = other.refCount;\n\n            if (refCount) {\n                (*refCount)++;\n            }\n        }\n        return *this;\n    }\n\n    // Move assignment operator\n    SmartPointer& operator=(SmartPointer&& other) noexcept {\n        if (this != &other) {\n            release();\n\n            ptr = other.ptr;\n            refCount = other.refCount;\n\n            other.ptr = nullptr;\n            other.refCount = nullptr;\n        }\n        return *this;\n    }\n\n    // Dereference operators\n    T& operator*() {\n        if (!ptr) {\n            throw std::runtime_error(\"Dereferencing null pointer\");\n        }\n        return *ptr;\n    }\n\n    const T& operator*() const {\n        if (!ptr) {\n            throw std::runtime_error(\"Dereferencing null pointer\");\n        }\n        return *ptr;\n    }\n\n    T* operator->() {\n        return ptr;\n    }\n\n    const T* operator->() const {\n        return ptr;\n    }\n\n    // Utility methods\n    T* get() { return ptr; }\n    const T* get() const { return ptr; }\n    unsigned use_count() const { return refCount ? *refCount : 0; }\n    bool unique() const { return use_count() == 1; }\n    bool empty() const { return ptr == nullptr; }\n\n    // Reset methods\n    void reset() {\n        release();\n        ptr = nullptr;\n        refCount = nullptr;\n    }\n\n    void reset(T* newPtr) {\n        release();\n        ptr = newPtr;\n        refCount = new unsigned(1);\n    }\n};\n\n// Comparison operators\ntemplate <typename T>\nbool operator==(const SmartPointer<T>& lhs, const SmartPointer<T>& rhs) {\n    return lhs.get() == rhs.get();\n}\n\ntemplate <typename T>\nbool operator!=(const SmartPointer<T>& lhs, const SmartPointer<T>& rhs) {\n    return !(lhs == rhs);\n}\n\n#endif // CUSTOM_SMART_POINTER_H\n```\n\nExample usage:\n\n```cpp\n#include <iostream>\n#include \"custom_smart_pointer.h\"\n\nclass TestClass {\npublic:\n    TestClass(int val) : value(val) {\n        std::cout << \"Constructor called\" << std::endl;\n    }\n    \n    ~TestClass() {\n        std::cout << \"Destructor called\" << std::endl;\n    }\n    \n    int getValue() const { return value; }\n\nprivate:\n    int value;\n};\n\nint main() {\n    // Create smart pointer\n    SmartPointer<TestClass> ptr1(new TestClass(42));\n    \n    // Copy constructor\n    SmartPointer<TestClass> ptr2 = ptr1;\n    \n    // Check reference count\n    std::cout << \"Reference count: \" << ptr1.use_count() << std::endl;\n    \n    // Dereference and access method\n    std::cout << \"Value: \" << ptr1->getValue() << std::endl;\n    \n    // Reset pointer\n    ptr1.reset();\n    \n    return 0;\n}\n```\n\nKey features of this custom smart pointer:\n\n1. Reference counting mechanism\n2. Copy and move semantics\n3. Safe resource management\n4. Exception handling\n5. Utility methods like `get()`, `use_count()`, `unique()`\n6. Template-based for flexibility\n7. Overloaded operators for intuitive use\n\nThe implementation provides:\n- Automatic memory management\n- Prevention of memory leaks\n- Reference counting\n- Safe pointer operations\n\nImprovements could include:\n- Adding more robust thread-safety\n- Supporting weak pointers\n- More comprehensive error handling\n\nThis implementation serves as a basic reference for creating a custom smart pointer class in C++.", "student_score": 0.4, "teacher_score": 0.85, "reward": 0.470587681661551, "scoring_breakdown": {"correctness": 0.3, "code_quality": 0.3, "efficiency": 0.2, "documentation": 0.2}, "timestamp": "2025-12-18T00:24:12.198261"}
{"prompt": "Write a function to reverse a linked list iteratively", "language": "cpp", "student_code": "```cpp\n#include <iostream>\n\nstruct Node {\n    int data;\n    Node* next;\n};\n\n// Function to reverse a linked list iteratively\nNode* reverseListIteratively(Node* head) {\n    Node* prev = nullptr;\n    Node* current = head;\n    Node* next = nullptr;\n\n    while (current != nullptr) {\n        next = current->next;  // Store next node\n        current->next = prev;  // Reverse current node's pointer\n        prev = current;        // Move pointers one position ahead\n        current = next;\n    }\n\n    return prev;  // New head of the", "teacher_code": "Here's a high-quality C++ implementation of reversing a linked list iteratively:\n\n```cpp\n/**\n * @brief Reverses a linked list iteratively\n * \n * This function reverses a singly linked list in-place with O(n) time complexity\n * and O(1) space complexity.\n * \n * @param head Pointer to the head of the linked list\n * @return ListNode* Pointer to the new head of the reversed list\n */\nListNode* reverseLinkedList(ListNode* head) {\n    // Handle edge cases: empty list or single node list\n    if (head == nullptr || head->next == nullptr) {\n        return head;\n    }\n\n    // Initialize three pointers for in-place reversal\n    ListNode* prev = nullptr;\n    ListNode* current = head;\n    ListNode* next = nullptr;\n\n    // Traverse and reverse links\n    while (current != nullptr) {\n        // Store next node before changing links\n        next = current->next;\n\n        // Reverse the current node's pointer\n        current->next = prev;\n\n        // Move pointers one step forward\n        prev = current;\n        current = next;\n    }\n\n    // Return the new head (previously the last node)\n    return prev;\n}\n```\n\nKey features of this implementation:\n\n1. Time Complexity: O(n)\n   - Traverses the list only once\n   - Each node is processed exactly once\n\n2. Space Complexity: O(1)\n   - In-place reversal\n   - Uses only a constant amount of extra space\n\n3. Handles edge cases:\n   - Empty list\n   - Single node list\n   - Multiple node list\n\n4. Clear and concise algorithm\n   - Uses three pointers for tracking\n   - Systematically reverses links\n\nExample usage:\n```cpp\n// Sample ListNode structure\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(nullptr) {}\n};\n\nint main() {\n    // Create a sample linked list: 1 -> 2 -> 3 -> 4 -> 5\n    ListNode* head = new ListNode(1);\n    head->next = new ListNode(2);\n    head->next->next = new ListNode(3);\n    head->next->next->next = new ListNode(4);\n    head->next->next->next->next = new ListNode(5);\n\n    // Reverse the list\n    head = reverseLinkedList(head);\n\n    // Now the list is: 5 -> 4 -> 3 -> 2 -> 1\n}\n```\n\nAdvantages:\n- Memory efficient\n- Simple and readable implementation\n- Works with lists of any length\n- No recursion overhead\n\nPotential improvements/variations:\n- Add error handling\n- Create a template version for generic types\n- Add boundary checks if needed", "student_score": 0.85, "teacher_score": 0.95, "reward": 0.8947359002779997, "scoring_breakdown": {"correctness": 0.3, "code_quality": 0.3, "efficiency": 0.2, "documentation": 0.2}, "timestamp": "2025-12-18T00:28:16.898488"}
{"prompt": "Write a function to calculate the factorial of a number using memoization", "language": "python", "student_code": "To calculate the factorial of a number using memoization in Python, you can use a dictionary to store previously computed factorials. This approach significantly reduces the number of redundant calculations, especially for larger numbers. Here's a high-quality implementation:\n\n```python\ndef factorial_memo(n, memo={}):\n    \"\"\"\n    Calculate the factorial of a number using memoization.\n\n    Args:\n        n (int): The number to calculate the factorial for.\n        memo (dict, optional): A dictionary to store previously computed factorials. Defaults to {}.\n\n    Returns:\n        int: The factorial of the given number.\n\n    Raises:\n        ValueError: If", "teacher_code": "Here's a high-quality Python implementation of factorial calculation using memoization:\n\n```python\nfrom functools import lru_cache\nfrom typing import Dict, Union\n\ndef factorial_memoized(func):\n    \"\"\"\n    A decorator that implements memoization for factorial calculation.\n    \n    Args:\n        func (callable): The factorial function to be memoized.\n    \n    Returns:\n        callable: A memoized version of the factorial function.\n    \"\"\"\n    cache: Dict[int, int] = {}\n    \n    def wrapper(n: int) -> int:\n        \"\"\"\n        Wrapper function to implement memoization.\n        \n        Args:\n            n (int): The number to calculate factorial for.\n        \n        Returns:\n            int: The factorial of the input number.\n        \n        Raises:\n            ValueError: If input is negative.\n        \"\"\"\n        # Check for invalid input\n        if n < 0:\n            raise ValueError(\"Factorial is not defined for negative numbers\")\n        \n        # Check if result is already in cache\n        if n in cache:\n            return cache[n]\n        \n        # Calculate and cache the result\n        if n <= 1:\n            result = 1\n        else:\n            result = n * wrapper(n - 1)\n        \n        cache[n] = result\n        return result\n    \n    return wrapper\n\n@factorial_memoized\ndef factorial(n: int) -> int:\n    \"\"\"\n    Calculate the factorial of a given number.\n    \n    Args:\n        n (int): The number to calculate factorial for.\n    \n    Returns:\n        int: The factorial of the input number.\n    \n    Examples:\n        >>> factorial(5)\n        120\n        >>> factorial(0)\n        1\n    \"\"\"\n    return n * factorial(n - 1) if n > 1 else 1\n\n# Alternative implementation using built-in lru_cache\n@lru_cache(maxsize=None)\ndef factorial_lru(n: int) -> int:\n    \"\"\"\n    Calculate factorial using Python's built-in LRU cache decorator.\n    \n    Args:\n        n (int): The number to calculate factorial for.\n    \n    Returns:\n        int: The factorial of the input number.\n    \n    Examples:\n        >>> factorial_lru(5)\n        120\n        >>> factorial_lru(0)\n        1\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    \n    return 1 if n <= 1 else n * factorial_lru(n - 1)\n\ndef main():\n    \"\"\"\n    Demonstration of factorial memoization.\n    \"\"\"\n    # Custom memoized implementation\n    print(\"Custom Memoized Factorial:\")\n    print(f\"Factorial of 5: {factorial(5)}\")\n    print(f\"Factorial of 0: {factorial(0)}\")\n    \n    # Built-in LRU cache implementation\n    print(\"\\nBuilt-in LRU Cache Factorial:\")\n    print(f\"Factorial of 5: {factorial_lru(5)}\")\n    print(f\"Factorial of 0: {factorial_lru(0)}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis implementation provides two approaches to factorial calculation with memoization:\n\n1. Custom Memoization Decorator:\n   - Uses a custom decorator `factorial_memoized`\n   - Implements manual caching with a dictionary\n   - Provides more control over caching mechanism\n   - Allows custom error handling\n\n2. Built-in LRU Cache:\n   - Uses Python's `@lru_cache` decorator\n   - Provides automatic memoization\n   - Simpler implementation\n   - Configurable cache size\n\nKey Features:\n- Type hints for improved readability and type checking\n- Comprehensive error handling\n- Docstrings with detailed documentation\n- Multiple implementation approaches\n- Performance optimization through memoization\n- Example usage in `main()` function\n\nPerformance Benefits:\n- Reduces redundant calculations\n- Improves time complexity from O(n) to O(1) for repeated calls\n- Saves computational resources\n\nUsage Example:\n```python\n# Calculate factorial\nresult = factorial(5)  # Returns 120\ncached_result = factorial(5)  # Retrieves from cache instantly\n```\n\nRecommendations:\n- Use `@lru_cache` for simpler scenarios\n- Use custom memoization for more complex caching requirements\n- Be cautious with large input values to prevent memory overflow\n\nThe code provides a clean, efficient, and well-documented solution for factorial calculation using memoization techniques.", "student_score": 0.5, "teacher_score": 0.95, "reward": 0.5263152354576469, "scoring_breakdown": {"correctness": 0.3, "code_quality": 0.3, "efficiency": 0.2, "documentation": 0.2}, "timestamp": "2025-12-18T00:28:22.672411"}
{"prompt": "Write a function to merge two sorted linked lists", "language": "python", "student_code": "```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef merge_sorted_lists(l1: ListNode, l2: ListNode) -> ListNode:\n    # Create a dummy node to act as the start of the merged list\n    dummy = ListNode()\n    current = dummy\n\n    # Traverse both lists and append the smaller value to the merged list\n    while l1 and l2:\n        if l1.val < l2.val:\n            current.next = l1\n            l1 = l1.next\n        else:\n            current", "teacher_code": "Here's a clean and efficient implementation of merging two sorted linked lists in Python:\n\n```python\nclass ListNode:\n    \"\"\"\n    Definition of a singly linked list node.\n    \n    Attributes:\n        val (int): Value stored in the node\n        next (ListNode): Reference to the next node\n    \"\"\"\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef merge_sorted_lists(list1: ListNode, list2: ListNode) -> ListNode:\n    \"\"\"\n    Merge two sorted linked lists into a single sorted linked list.\n    \n    Args:\n        list1 (ListNode): Head of the first sorted linked list\n        list2 (ListNode): Head of the second sorted linked list\n    \n    Returns:\n        ListNode: Head of the merged sorted linked list\n    \n    Time Complexity: O(m + n), where m and n are lengths of input lists\n    Space Complexity: O(1), as merging is done in-place\n    \"\"\"\n    # Create a dummy node as the head of the merged list\n    dummy = ListNode(0)\n    current = dummy\n    \n    # Traverse both lists and compare nodes\n    while list1 and list2:\n        if list1.val <= list2.val:\n            current.next = list1\n            list1 = list1.next\n        else:\n            current.next = list2\n            list2 = list2.next\n        \n        current = current.next\n    \n    # Attach remaining nodes from non-empty list\n    if list1:\n        current.next = list1\n    if list2:\n        current.next = list2\n    \n    return dummy.next\n\n# Helper function to create a linked list from a list of values\ndef create_linked_list(values):\n    \"\"\"\n    Create a linked list from a list of values.\n    \n    Args:\n        values (list): List of values to create the linked list\n    \n    Returns:\n        ListNode: Head of the created linked list\n    \"\"\"\n    if not values:\n        return None\n    \n    head = ListNode(values[0])\n    current = head\n    \n    for val in values[1:]:\n        current.next = ListNode(val)\n        current = current.next\n    \n    return head\n\n# Helper function to print a linked list\ndef print_linked_list(head):\n    \"\"\"\n    Print the values of a linked list.\n    \n    Args:\n        head (ListNode): Head of the linked list\n    \"\"\"\n    current = head\n    while current:\n        print(current.val, end=\" -> \")\n        current = current.next\n    print(\"None\")\n\n# Example usage\ndef main():\n    # Create two sorted linked lists\n    list1 = create_linked_list([1, 3, 5, 7])\n    list2 = create_linked_list([2, 4, 6, 8])\n    \n    print(\"List 1:\")\n    print_linked_list(list1)\n    \n    print(\"List 2:\")\n    print_linked_list(list2)\n    \n    # Merge the lists\n    merged_list = merge_sorted_lists(list1, list2)\n    \n    print(\"Merged List:\")\n    print_linked_list(merged_list)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis implementation provides a comprehensive solution for merging two sorted linked lists with the following key features:\n\n1. `ListNode` class:\n   - Represents a node in a singly linked list\n   - Stores a value and a reference to the next node\n\n2. `merge_sorted_lists()` function:\n   - Efficiently merges two sorted linked lists\n   - Uses a dummy node to simplify merging process\n   - Time complexity: O(m + n)\n   - Space complexity: O(1)\n\n3. Helper functions:\n   - `create_linked_list()`: Creates a linked list from a list of values\n   - `print_linked_list()`: Prints the values of a linked list\n\n4. Main method demonstrates usage with example lists\n\nKey advantages of this implementation:\n- In-place merging\n- Handles lists of different lengths\n- Clear and concise code\n- Proper type hinting\n- Comprehensive documentation\n\nExample output:\n```\nList 1:\n1 -> 3 -> 5 -> 7 -> None\nList 2:\n2 -> 4 -> 6 -> 8 -> None\nMerged List:\n1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> None\n```\n\nThe code is modular, readable, and follows Python best practices. It can be easily integrated into larger projects or used as a standalone utility for merging sorted linked lists.", "student_score": 0.4, "teacher_score": 0.95, "reward": 0.4210521883661175, "scoring_breakdown": {"correctness": 0.3, "code_quality": 0.3, "efficiency": 0.2, "documentation": 0.2}, "timestamp": "2025-12-18T00:32:35.830580"}
{"prompt": "Create a generic function to sort a vector in-place", "language": "rust", "student_code": "```rust\nfn in_place_sort<T: Ord>(vec: &mut Vec<T>) {\n    vec.sort();\n}\n```\n\nThis function takes a mutable reference to a vector of any type that implements the `Ord` (orderable) trait and sorts it in-place using the `sort` method provided by the `Vec` type. The `Ord` trait is used to ensure that the type `T` can be compared for ordering, which is necessary for sorting. The `sort` method is a stable, comparison-based sort that is efficient for most use cases. ```rust\nfn in_place_sort<T: Ord + Copy>(", "teacher_code": "Here's a high-quality, generic implementation of an in-place vector sorting function in Rust:\n\n```rust\n/// Sorts a vector in-place using the standard library's sorting algorithm.\n///\n/// This function uses a generic type `T` that implements the `Ord` trait,\n/// which allows comparison and ordering of elements.\n///\n/// # Arguments\n///\n/// * `vec` - A mutable reference to the vector to be sorted\n///\n/// # Examples\n///\n/// ```\n/// let mut numbers = vec![5, 2, 8, 1, 9];\n/// sort_vector(&mut numbers);\n/// assert_eq!(numbers, vec![1, 2, 5, 8, 9]);\n///\n/// let mut strings = vec![\"banana\", \"apple\", \"cherry\"];\n/// sort_vector(&mut strings);\n/// assert_eq!(strings, vec![\"apple\", \"banana\", \"cherry\"]);\n/// ```\npub fn sort_vector<T: Ord>(vec: &mut Vec<T>) {\n    vec.sort();\n}\n\n/// Sorts a vector in-place with a custom comparator function.\n///\n/// This function allows more flexible sorting by providing a custom\n/// comparison function.\n///\n/// # Arguments\n///\n/// * `vec` - A mutable reference to the vector to be sorted\n/// * `comparator` - A closure that defines the custom sorting logic\n///\n/// # Examples\n///\n/// ```\n/// let mut numbers = vec![5, 2, 8, 1, 9];\n/// sort_vector_by(&mut numbers, |a, b| b.cmp(a)); // Descending order\n/// assert_eq!(numbers, vec![9, 8, 5, 2, 1]);\n/// ```\npub fn sort_vector_by<T>(vec: &mut Vec<T>, comparator: impl Fn(&T, &T) -> std::cmp::Ordering) {\n    vec.sort_by(comparator);\n}\n\n/// Sorts a vector in-place using a key extraction function.\n///\n/// This is useful when you want to sort based on a specific attribute\n/// or transformed value of the elements.\n///\n/// # Arguments\n///\n/// * `vec` - A mutable reference to the vector to be sorted\n/// * `key_fn` - A closure that extracts a comparable key from each element\n///\n/// # Examples\n///\n/// ```\n/// #[derive(Debug, Eq, PartialEq)]\n/// struct Person {\n///     name: String,\n///     age: u32,\n/// }\n///\n/// let mut people = vec![\n///     Person { name: \"Alice\".to_string(), age: 30 },\n///     Person { name: \"Bob\".to_string(), age: 25 },\n///     Person { name: \"Charlie\".to_string(), age: 35 },\n/// ];\n///\n/// sort_vector_by_key(&mut people, |p| p.age);\n/// assert_eq!(people[0].name, \"Bob\");\n/// assert_eq!(people[1].name, \"Alice\");\n/// assert_eq!(people[2].name, \"Charlie\");\n/// ```\npub fn sort_vector_by_key<T, K: Ord>(vec: &mut Vec<T>, key_fn: impl Fn(&T) -> K) {\n    vec.sort_by_key(key_fn);\n}\n\n// Optional: Demonstration of usage\nfn main() {\n    // Basic integer sorting\n    let mut numbers = vec![5, 2, 8, 1, 9];\n    sort_vector(&mut numbers);\n    println!(\"Sorted numbers: {:?}\", numbers);\n\n    // Custom comparator sorting\n    let mut chars = vec!['z', 'a', 'x', 'b'];\n    sort_vector_by(&mut chars, |a, b| b.cmp(a)); // Reverse order\n    println!(\"Reverse sorted chars: {:?}\", chars);\n\n    // Sorting by key\n    #[derive(Debug)]\n    struct Item {\n        value: i32,\n        weight: u32,\n    }\n\n    let mut items = vec![\n        Item { value: 10, weight: 5 },\n        Item { value: 5, weight: 3 },\n        Item { value: 15, weight: 8 },\n    ];\n\n    sort_vector_by_key(&mut items, |item| item.weight);\n    println!(\"Sorted by weight: {:?}\", items);\n}\n```\n\nThis implementation provides three generic sorting functions:\n\n1. `sort_vector`: A simple in-place sort using the default ordering.\n2. `sort_vector_by`: Allows custom comparison logic.\n3. `sort_vector_by_key`: Sorts based on a key extraction function.\n\nKey features:\n- Generic type support\n- Comprehensive documentation\n- Multiple sorting strategies\n- Type-safe comparisons\n- Flexible key extraction\n- Performance-efficient using Rust's standard library sorting\n\nThe code includes:\n- Clear function signatures\n- Detailed documentation\n- Comprehensive examples\n- Error-free sorting approaches\n\nThe functions leverage Rust's powerful trait system and closure capabilities to provide flexible, performant sorting.", "student_score": 0.9, "teacher_score": 0.95, "reward": 0.9473674238237645, "scoring_breakdown": {"correctness": 0.3, "code_quality": 0.3, "efficiency": 0.2, "documentation": 0.2}, "timestamp": "2025-12-18T00:36:53.604301"}
{"prompt": "Write a template function to find the maximum element in a container", "language": "cpp", "student_code": "```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\ntemplate <typename T>\nT find_max(const std::vector<T>& container) {\n    return *std::max_element(container.begin(), container.end());\n}\n\nint main() {\n    std::vector<int> intVec = {1, 3, 5, 7, 9};\n    std::vector<double> doubleVec = {1.1, 3.3, 5.5, 7.7, 9.9};\n\n    std::cout << \"Max int: \" << find_max(intVec) << std::endl", "teacher_code": "Here's a high-quality C++ template function to find the maximum element in a container:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <stdexcept>\n#include <type_traits>\n\n/**\n * @brief Find the maximum element in a given container\n * \n * @tparam ContainerType The type of the container\n * @param container The input container to search\n * @return The maximum element in the container\n * @throws std::invalid_argument If the container is empty\n */\ntemplate <typename ContainerType>\ntypename ContainerType::value_type findMaxElement(const ContainerType& container) {\n    // Check if the container is empty\n    if (container.empty()) {\n        throw std::invalid_argument(\"Container is empty\");\n    }\n\n    // Use std::max_element for efficient maximum finding\n    auto maxIt = std::max_element(container.begin(), container.end());\n    \n    // Return the maximum element\n    return *maxIt;\n}\n\n/**\n * @brief Overloaded version for raw arrays\n * \n * @tparam T The type of array elements\n * @tparam Size The size of the array\n * @param arr The input array to search\n * @return The maximum element in the array\n * @throws std::invalid_argument If the array is empty\n */\ntemplate <typename T, std::size_t Size>\nT findMaxElement(const T (&arr)[Size]) {\n    // Check if the array is empty\n    if (Size == 0) {\n        throw std::invalid_argument(\"Array is empty\");\n    }\n\n    // Use std::max_element for efficient maximum finding\n    return *std::max_element(std::begin(arr), std::end(arr));\n}\n\n// Example usage and demonstration\nint main() {\n    // Test with vector\n    std::vector<int> vec = {5, 2, 8, 1, 9, 3};\n    try {\n        int maxVec = findMaxElement(vec);\n        std::cout << \"Max in vector: \" << maxVec << std::endl;\n    } catch (const std::invalid_argument& e) {\n        std::cerr << e.what() << std::endl;\n    }\n\n    // Test with list\n    std::list<double> lst = {3.14, 2.71, 1.41, 5.0};\n    try {\n        double maxList = findMaxElement(lst);\n        std::cout << \"Max in list: \" << maxList << std::endl;\n    } catch (const std::invalid_argument& e) {\n        std::cerr << e.what() << std::endl;\n    }\n\n    // Test with raw array\n    int arr[] = {10, 5, 8, 12, 3};\n    try {\n        int maxArr = findMaxElement(arr);\n        std::cout << \"Max in array: \" << maxArr << std::endl;\n    } catch (const std::invalid_argument& e) {\n        std::cerr << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```\n\nThis implementation offers several key features:\n\n1. Template Function Design\n- Uses C++ templates for generic container support\n- Works with standard containers like `vector`, `list`, etc.\n- Supports raw arrays as well\n\n2. Error Handling\n- Throws `std::invalid_argument` for empty containers\n- Provides clear error messages\n\n3. Efficiency\n- Utilizes `std::max_element` for optimal performance\n- Uses standard library algorithms\n- Minimal overhead compared to manual iteration\n\n4. Flexibility\n- Compatible with different container types\n- Works with various element types that support comparison\n\n5. Modern C++ Practices\n- Uses `auto` for type deduction\n- Follows RAII principles\n- Uses exception handling\n\n6. Comprehensive Example\n- Demonstrates usage with different container types\n- Shows error handling approach\n\nKey Points:\n- Time Complexity: O(n)\n- Space Complexity: O(1)\n- Supports STL containers and raw arrays\n- Type-safe and exception-safe\n\nPotential Improvements:\n- Could add compile-time checks for comparable types\n- Optionally support custom comparators\n- Add more sophisticated error handling\n\nCompile with C++11 or later: `g++ -std=c++11 max_element.cpp`", "student_score": 0.85, "teacher_score": 0.95, "reward": 0.8947359002779997, "scoring_breakdown": {"correctness": 0.3, "code_quality": 0.3, "efficiency": 0.2, "documentation": 0.2}, "timestamp": "2025-12-18T00:41:01.146297"}
{"prompt": "Implement a function to find the longest common subsequence between two strings", "language": "python", "student_code": "```python\ndef longest_common_subsequence(str1: str, str2: str) -> str:\n    \"\"\"\n    Finds the longest common subsequence between two strings.\n    \n    :param str1: First input string.\n    :param str2: Second input string.\n    :return: The longest common subsequence as a string.\n    \"\"\"\n    m, n = len(str1), len(str2)\n    dp = [[\"\" for _ in range(n+1)] for _ in range(m+1)]\n    \n    for i in range(1, m+1):\n        for j in range(1, n+1", "teacher_code": "Here's a high-quality Python implementation of finding the longest common subsequence (LCS) using dynamic programming:\n\n```python\ndef longest_common_subsequence(str1: str, str2: str) -> str:\n    \"\"\"\n    Find the longest common subsequence between two strings.\n    \n    Args:\n        str1 (str): First input string\n        str2 (str): Second input string\n    \n    Returns:\n        str: The longest common subsequence\n    \n    Time Complexity: O(m*n)\n    Space Complexity: O(m*n)\n    \"\"\"\n    # Handle edge cases\n    if not str1 or not str2:\n        return \"\"\n    \n    # Get string lengths\n    m, n = len(str1), len(str2)\n    \n    # Create DP table\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Populate DP table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i-1] == str2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    \n    # Reconstruct LCS\n    lcs = []\n    i, j = m, n\n    while i > 0 and j > 0:\n        if str1[i-1] == str2[j-1]:\n            lcs.append(str1[i-1])\n            i -= 1\n            j -= 1\n        elif dp[i-1][j] > dp[i][j-1]:\n            i -= 1\n        else:\n            j -= 1\n    \n    # Reverse to get correct order\n    return ''.join(reversed(lcs))\n\n\ndef lcs_length(str1: str, str2: str) -> int:\n    \"\"\"\n    Calculate the length of the longest common subsequence.\n    \n    Args:\n        str1 (str): First input string\n        str2 (str): Second input string\n    \n    Returns:\n        int: Length of the longest common subsequence\n    \n    Time Complexity: O(m*n)\n    Space Complexity: O(min(m,n))\n    \"\"\"\n    # Ensure str1 is the shorter string for optimization\n    if len(str1) > len(str2):\n        str1, str2 = str2, str1\n    \n    m, n = len(str1), len(str2)\n    \n    # Use 1D DP for space optimization\n    previous = [0] * (m + 1)\n    current = [0] * (m + 1)\n    \n    for j in range(1, n + 1):\n        for i in range(1, m + 1):\n            if str1[i-1] == str2[j-1]:\n                current[i] = previous[i-1] + 1\n            else:\n                current[i] = max(previous[i], current[i-1])\n        \n        previous, current = current, previous\n    \n    return previous[m]\n\n\n# Example usage and testing\ndef main():\n    # Test cases\n    test_cases = [\n        (\"ABCDGH\", \"AEDFHR\"),   # Partial match\n        (\"AGGTAB\", \"GXTXAYB\"),  # Longer subsequence\n        (\"\", \"ABC\"),            # Empty string\n        (\"ABC\", \"ABC\"),         # Exact match\n        (\"ABCBDAB\", \"BDCABA\")   # Complex case\n    ]\n    \n    print(\"Longest Common Subsequence Examples:\")\n    for str1, str2 in test_cases:\n        result = longest_common_subsequence(str1, str2)\n        length = lcs_length(str1, str2)\n        print(f\"Strings: {str1}, {str2}\")\n        print(f\"LCS: {result}\")\n        print(f\"LCS Length: {length}\\n\")\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis implementation provides two key functions:\n\n1. `longest_common_subsequence()`:\n   - Finds the actual longest common subsequence\n   - Uses 2D dynamic programming\n   - Returns the LCS as a string\n   - Time Complexity: O(m*n)\n   - Space Complexity: O(m*n)\n\n2. `lcs_length()`:\n   - Calculates the length of the LCS\n   - Uses space-optimized 1D dynamic programming\n   - Time Complexity: O(m*n)\n   - Space Complexity: O(min(m,n))\n\nKey Features:\n- Type hints for better readability\n- Docstrings explaining function behavior\n- Handles edge cases (empty strings)\n- Efficient dynamic programming approach\n- Includes example usage and testing\n\nThe code demonstrates:\n- Dynamic programming technique\n- String manipulation\n- Space and time complexity optimization\n- Robust error handling\n\nWhen you run this script, it will output the longest common subsequence and its length for various test cases.\n\nPossible improvements:\n- Add more comprehensive error checking\n- Support for Unicode strings\n- Parallel processing for very large strings", "student_score": 0.2, "teacher_score": 0.95, "reward": 0.21052609418305876, "scoring_breakdown": {"correctness": 0.3, "code_quality": 0.3, "efficiency": 0.2, "documentation": 0.2}, "timestamp": "2025-12-18T00:41:02.370067"}
{"prompt": "Implement a thread-safe singleton pattern in C++", "language": "cpp", "student_code": "```cpp\n#include <iostream>\n#include <mutex>\n\nclass Singleton {\npublic:\n    static Singleton& getInstance() {\n        std::lock_guard<std::mutex> lock(m_mutex);\n        if (m_instance == nullptr) {\n            m_instance = new Singleton();\n        }\n        return *m_instance;\n    }\n\n    // Add your methods here\n\nprivate:\n    Singleton() = default;\n    Singleton(const Singleton&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n\n    static Singleton* m_instance;\n    static std::mutex m_mutex;\n};\n\nSingleton* Singleton::m_instance = nullptr;\nstd::mutex Singleton::m_mutex", "teacher_code": "Here's a robust and thread-safe implementation of the Singleton pattern in C++11 and later:\n\n```cpp\n#include <iostream>\n#include <mutex>\n#include <memory>\n\nclass Singleton {\npublic:\n    // Delete copy constructor and assignment operator\n    Singleton(const Singleton&) = delete;\n    Singleton& operator=(const Singleton&) = delete;\n\n    // Static method to get the singleton instance\n    static Singleton& getInstance() {\n        // Use Meyer's Singleton - thread-safe and lazy initialization\n        static Singleton instance;\n        return instance;\n    }\n\n    // Example method to demonstrate functionality\n    void doSomething() {\n        std::cout << \"Singleton is doing something.\" << std::endl;\n    }\n\nprivate:\n    // Private constructor to prevent direct instantiation\n    Singleton() = default;\n\n    // Optional: destructor (if needed)\n    ~Singleton() = default;\n};\n\n// Alternative implementation using std::call_once (more explicit)\nclass ThreadSafeSingleton {\npublic:\n    static ThreadSafeSingleton& getInstance() {\n        std::call_once(initInstanceFlag, &ThreadSafeSingleton::initSingleton);\n        return *instance;\n    }\n\n    void performAction() {\n        std::cout << \"Thread-safe singleton action\" << std::endl;\n    }\n\nprivate:\n    // Prevent copying\n    ThreadSafeSingleton(const ThreadSafeSingleton&) = delete;\n    ThreadSafeSingleton& operator=(const ThreadSafeSingleton&) = delete;\n\n    // Private constructor\n    ThreadSafeSingleton() = default;\n\n    // Static method to initialize instance\n    static void initSingleton() {\n        instance = new ThreadSafeSingleton();\n    }\n\n    // Static members\n    static std::once_flag initInstanceFlag;\n    static ThreadSafeSingleton* instance;\n};\n\n// Static member initialization\nstd::once_flag ThreadSafeSingleton::initInstanceFlag;\nThreadSafeSingleton* ThreadSafeSingleton::instance = nullptr;\n\n// Example usage\nint main() {\n    // Meyer's Singleton usage\n    Singleton& singleton1 = Singleton::getInstance();\n    Singleton& singleton2 = Singleton::getInstance();\n\n    // Verify it's the same instance\n    std::cout << \"Singleton addresses match: \" \n              << (&singleton1 == &singleton2) << std::endl;\n\n    singleton1.doSomething();\n\n    // Thread-safe singleton usage\n    ThreadSafeSingleton& threadSafeSingleton = \n        ThreadSafeSingleton::getInstance();\n    threadSafeSingleton.performAction();\n\n    return 0;\n}\n```\n\nThis implementation provides two approaches to thread-safe singleton:\n\n1. Meyer's Singleton (Recommended):\n   - Uses C++11's magic statics\n   - Guaranteed thread-safe by the C++ standard\n   - Lazy initialization\n   - Simple and concise\n   - No manual memory management\n\n2. Explicit Thread-Safe Singleton:\n   - Uses `std::call_once` for thread-safe initialization\n   - More verbose but provides more control\n   - Allows for more complex initialization if needed\n\nKey Features:\n- Prevents multiple instantiation\n- Thread-safe initialization\n- Prevents copy and assignment\n- Lazy initialization\n- Modern C++ practices\n\nBest Practices Demonstrated:\n- Deleted copy constructor and assignment operators\n- Private constructor\n- Static method for instance access\n- Use of `std::call_once` and magic statics\n- RAII principles\n\nConsiderations:\n- Choose Meyer's Singleton for simplicity\n- Use explicit implementation if you need more complex initialization\n- Always consider if a singleton is truly necessary\n\nCompilation Requirements:\n- C++11 or later\n- Compile with `-std=c++11` or higher\n\nPotential Improvements:\n- Add logging\n- Implement move semantics if needed\n- Add error handling for complex initializations", "student_score": 0.6, "teacher_score": 0.95, "reward": 0.6315782825491763, "scoring_breakdown": {"correctness": 0.3, "code_quality": 0.3, "efficiency": 0.2, "documentation": 0.2}, "timestamp": "2025-12-18T00:41:18.240709"}
{"prompt": "Write a function to parse a JSON string safely", "language": "rust", "student_code": "\n\n```rust\nuse serde_json::from_str;\n\nfn parse_json(json_str: &str) -> Result<serde_json::Value, serde_json::Error> {\n    from_str(json_str)\n}\n\nfn main() {\n    let json_str = r#\"{\"name\": \"John\", \"age\": 30, \"city\": \"New York\"}\"#;\n    match parse_json(json_str) {\n        Ok(data) => println!(\"Parsed data: {:?}\", data),\n        Err(e) => eprintln!(\"Error parsing JSON: {}\", e),\n    }\n}\n```\n\nThis code defines a `parse_json` function that takes a JSON", "teacher_code": "Here's a robust and safe JSON parsing function in Rust using the `serde_json` crate:\n\n```rust\nuse serde_json::{Value, from_str};\nuse std::result::Result;\n\n/// Safely parse a JSON string into a JSON Value\n///\n/// # Arguments\n///\n/// * `json_str` - A string slice containing the JSON to parse\n///\n/// # Returns\n///\n/// * `Result<Value, serde_json::Error>` - Parsed JSON value or parsing error\n///\n/// # Examples\n///\n/// ```\n/// let json_str = r#\"{\"name\": \"John\", \"age\": 30}\"#;\n/// match parse_json(json_str) {\n///     Ok(value) => println!(\"Parsed successfully: {}\", value),\n///     Err(e) => eprintln!(\"JSON parsing error: {}\", e)\n/// }\n/// ```\npub fn parse_json(json_str: &str) -> Result<Value, serde_json::Error> {\n    // Trim whitespace to handle potential leading/trailing spaces\n    let trimmed_json = json_str.trim();\n\n    // Check if the string is empty before parsing\n    if trimmed_json.is_empty() {\n        return Err(serde_json::Error::custom(\"Empty JSON string\"));\n    }\n\n    // Use serde_json's from_str for robust parsing\n    from_str(trimmed_json)\n}\n\n/// Safely parse a JSON string into a specific type\n///\n/// # Arguments\n///\n/// * `json_str` - A string slice containing the JSON to parse\n///\n/// # Returns\n///\n/// * `Result<T, serde_json::Error>` - Parsed JSON as specified type or parsing error\n///\n/// # Examples\n///\n/// ```\n/// #[derive(Deserialize)]\n/// struct Person {\n///     name: String,\n///     age: u32\n/// }\n///\n/// let json_str = r#\"{\"name\": \"John\", \"age\": 30}\"#;\n/// match parse_json_as::<Person>(json_str) {\n///     Ok(person) => println!(\"Name: {}, Age: {}\", person.name, person.age),\n///     Err(e) => eprintln!(\"JSON parsing error: {}\", e)\n/// }\n/// ```\npub fn parse_json_as<T>(json_str: &str) -> Result<T, serde_json::Error>\nwhere\n    T: serde::de::DeserializeOwned,\n{\n    // Trim whitespace to handle potential leading/trailing spaces\n    let trimmed_json = json_str.trim();\n\n    // Check if the string is empty before parsing\n    if trimmed_json.is_empty() {\n        return Err(serde_json::Error::custom(\"Empty JSON string\"));\n    }\n\n    // Use serde_json's from_str for robust parsing\n    serde_json::from_str(trimmed_json)\n}\n\n/// Validate a JSON string without parsing its contents\n///\n/// # Arguments\n///\n/// * `json_str` - A string slice containing the JSON to validate\n///\n/// # Returns\n///\n/// * `bool` - Whether the JSON is valid\n///\n/// # Examples\n///\n/// ```\n/// let valid_json = r#\"{\"name\": \"John\", \"age\": 30}\"#;\n/// let invalid_json = r#\"{\"name\": \"John\", \"age\": }\"#;\n///\n/// assert!(is_valid_json(valid_json));\n/// assert!(!is_valid_json(invalid_json));\n/// ```\npub fn is_valid_json(json_str: &str) -> bool {\n    // Trim whitespace\n    let trimmed_json = json_str.trim();\n\n    // Check if empty\n    if trimmed_json.is_empty() {\n        return false;\n    }\n\n    // Attempt to parse and discard the result\n    from_str::<Value>(trimmed_json).is_ok()\n}\n\n// Optional: Error handling utility\n#[derive(Debug)]\npub enum JsonParseError {\n    EmptyInput,\n    ParseError(serde_json::Error),\n}\n\nimpl From<serde_json::Error> for JsonParseError {\n    fn from(err: serde_json::Error) -> Self {\n        JsonParseError::ParseError(err)\n    }\n}\n\n// Recommended dependencies in Cargo.toml:\n// [dependencies]\n// serde = { version = \"1.0\", features = [\"derive\"] }\n// serde_json = \"1.0\"\n```\n\nThis implementation provides several robust JSON parsing utilities:\n\n1. `parse_json()`: Parses JSON into a generic `serde_json::Value`\n2. `parse_json_as()`: Parses JSON into a specific type\n3. `is_valid_json()`: Validates JSON without full parsing\n4. Custom error handling with `JsonParseError`\n\nKey features:\n- Safe parsing with error handling\n- Whitespace trimming\n- Empty input detection\n- Generic type support\n- Comprehensive documentation\n- Example usage in doc comments\n\nBest practices demonstrated:\n- Use of `Result` for error handling\n- Trait bounds (`DeserializeOwned`)\n- Comprehensive error checking\n- Clear, descriptive function signatures\n\nRecommended usage with `Cargo.toml` dependencies for `serde` and `serde_json`.", "student_score": 0.85, "teacher_score": 0.95, "reward": 0.8947359002779997, "scoring_breakdown": {"correctness": 0.3, "code_quality": 0.3, "efficiency": 0.2, "documentation": 0.2}, "timestamp": "2025-12-18T00:56:56.231444"}
